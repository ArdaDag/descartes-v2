// Copyright (C) 2020 Cartesi Pte. Ltd.

// SPDX-License-Identifier: GPL-3.0-only
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.

// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Note: This component currently has dependencies that are licensed under the GNU
// GPL, version 3, and so you should treat this component as a whole as being under
// the GPL version 3. But all Cartesi-written code in this component is licensed
// under the Apache License, version 2, or a compatible permissive license, and can
// be used independently under the Apache v2 license. After this component is
// rewritten, the entire component will be released under the Apache v2 license.


/// @title Interface DescartesV2 contract
pragma solidity ^0.7.0;


// TODO: Should this be an instantiator?
contract DescartesV2 {

    State state; // current state
    Epoch[] epochs; // list of all epochs - elements of this list are always
                    // finalize

    // inputs received during InputAccumulation will be included in the
    // current epoch. Inputs received while WaitingClaims or ChallengesInProgress
    // are accumulated for N + 1
    enum Phase {InputAccumulation, WaitingClaims, ChallengesInProgress};

    bytes32[] inputs; // global inbox of inputs, inputs are hashes

    // TODO: Is this the minimum time? And then the claimers can be flexible about it
    // or is this always the same (defined on the constructor/instantiate)?
    uint64 inputWindow;  // time in seconds each epoch waits for inputs
                         // if there is a challenge/invalid state, the inputs
                         // get accumulated to the next epoch

    uint64 claimDeadline; // after claimDeadline seconds after last input checkpoint
                          // anyone can claim a state (so validators cannot freeze withdrawals forever)
    uint64 challengeDeadline; // after challengeDeadline seconds a new claim can be accepted


    // THE BRIDGE CONTRACT WILL DEAL WITH OUTPUTS - will keep track of dependencies
    // and figure out if they were executed or not
    // DescartesV2 only keeps the summary of all outputs, using the Merkle Hash
    bytes32 outputsMRH; // Merkle root hash of outputs


    address logger; // address of logger contract
    address inputValidator; // if input is permissionless, == 0x00
                            // if not, this is a contract
    address quorum; // contract that manages the quorum

    // TODO: Invalid might be analogous to Finalized with different hash/claimer
    enum status {Pending, Finalized, Challenged, Invalid}

    struct Epoch {
        bytes32 state; // machine hash at the end of this epoch
        bytes32 epochOutputs; // hash of outputs from this epoch
        bytes32 epochLogs; // hash of the logs
        uint32 lastInput; // max uint32 ~= 4e+9, thats enough right?
    }

    struct State {
        bytes32 stateHash; // updated hash of cartesi machine
        uint256 maxCycle; // max number of machine cycle to run
        uint256 timestamp; // timestamp of claim submission
        address claimer; // claimed by

        //TODO: do we need a list of challengers?
        address challenger; // if !status.Challenged, challenger == 0x00

        address[] attestators; // validators that attested the validity of state

        uint64 inputCheckpoint; // index of last input this epoch.
        bytes32 outputMetaHash; // merkle root hash of all outputs generated by this state
        status currentStatus; // status of claimed machine state
    }

    struct Output {
        bytes32 outputHash; // hash of output - includes destination, payload, input hash and maybe highestGas

        // THIS MOVES TO THE BRIDGE CONTRACT
        bool executed; // true if executed without reverting
        bytes32[] dependencies; // outputs that this output depends on
                                // can only be executed if all of them have been
                                // properly executed (executed == true)
    }

    // this will be a contract
    struct Quorum {
        uint256 size; // size of quorum
        address[] validators;
        // func addMember;
        // func kickMember;
        // func penalizeMember;
        // func isValidator;
    }


    function addInput(bytes32 _input, bytes32 _payload) {
        // prepend msg.sender and timestamp (maybe blockhash)?
        // if inputValidator != 0x00, require(inputValidator.validate(_input, msg.sender)

        // add input

    }

    function claim(bytes32 _finalHash, uint256 _maxCycle,  bytes32 outputs) {
        // if phase == InputAccumulation
        //      require time > minimum duration

        // require msg.sender is validator OR timestamp > challengeDeadline

        // require outputs is cointained in the final hash

        // if first claim for new state
        //      add state to epoch list
        //      state.stateHash = _finalHash
        //// dont need initial hash, its equal epochs[epochs.length() - 1].state)

        // else if !new state
        //      if _finalHash == state.stateHash && maxCycle == && outputs ==
        //          add as attestator
        //          if every quorum member attested, Phase -> InputAccumulation
        //      else Phase -> ChallengesInProgress

    }

    function finalizeState() {
        // anyone can call

        // require phase == WaitingClaims && claim deadline passed
        // ||
        // require phase == ChallengeInProgress && challenge deadline passed
    }

    function executeOutput(
        Epoch _outputEpoch,
        bytes32 _outputHash,
        uint256 _outputIndex, // index of the output leaf
        bytes32[] _inputSiblings, // Siblings to prove inputs merkle root hash
        bytes32[] _outputSiblings, // Siblings to prove outputs merkle root hash
        bytes32 _payload, // should be contained in outputHash?
        address _destination // should be contained in outputHash?
    ) returns (bool) {
        if (executed[_outputHash]) return true;
    }
}
